<html>
	<head>
		<meta charset="utf-8">
		<title>Projeto ecs4</title>
		
		<script src="https://d3js.org/d3.v5.min.js" />x
		
		<script src="https://unpkg.com/d3-array@1"></script>
		<script src="https://unpkg.com/d3-collection@1"></script>
		<script src="https://unpkg.com/d3-path@1"></script>
		<script src="https://unpkg.com/d3-shape@1"></script>
		<script src="https://unpkg.com/d3-sankey@0"></script>
	</head>
	<body>
	
		<datalist id="tickmarks">
			<option value="0" />
			<option value="10" />
			<option value="20" />
			<option value="30" />
			<option value="40" />
			<option value="50" />
			<option value="60" />
			<option value="70" />
			<option value="80" />
			<option value="90" />
			<option value="100" />
			<option value="200" />
			<option value="300" />
			<option value="400" />
		</datalist>

		<script>
//  Classes  //
			class QualityInfo {
				constructor(element) {
					this.qaDefault = element.qaDefault;
					this.qaDPI = +element.qaDPI;
					this.qaDensity = +element.qaDensity;
					this.qaInclination = +element.qaInclination;
					this.qaLightness = +element.qaLightness;
					this.qaShadow = +element.qaShadow;
					this.qaFocus = +element.qaFocus;
					this.qaShine = +element.qaShine;
				}
				getResult() {
					let isValid = false;
					let nameValue = "";
					let colorValue = "#dd0000";
					
					if (!(this.qaDefault === "OK")) {
						nameValue = this.qaDefault;
						colorValue = "#dddddd";
					}
					else if (this.qaDPI < getSliderValue("qaDpi")){
						nameValue = "Resolução (DPI)";
					}
					else if (100 * this.qaDensity < getSliderValue("qaDensity")){
						nameValue = "Densidade";
					}
					else if (this.qaInclination > getSliderValue("qaInclination")){
						nameValue = "Inclinação";
					}
					else if (100 * this.qaLightness < getSliderValue("qaLightness")){
						nameValue = "Iluminação";
					}
					else if (100 * this.qaShadow < getSliderValue("qaShadow")){
						nameValue = "Sombra";
					}
					else if (100 * this.qaFocus < getSliderValue("qaFocus")){
						nameValue = "Foco";
					}
					else if (100 * this.qaShine < getSliderValue("qaShine")){
						nameValue = "Brilho";
					}
					else {
						isValid = true;
						nameValue = "OK";
						colorValue = "#00dd00";
					}
					
					return [isValid, nameValue, colorValue];
				}
			}
			
			class ClassificationInfo {
				constructor(element) {
					this.classification = element.classification;
					this.confidence = +element.classificationConf;
				}
				getResult() {
					if (100 * this.confidence >= getSliderValue("classifConf")){
						let isValid = this.classification === "rg_back";
						return [isValid, this.classification, isValid ? "#00dd00" : "#dd0000"];
					}
					else {
						return [false, "Desconhecido", "#dddddd"];
					}
				}
			}
			
			class ExtractionInfo {
				constructor(infoName, sim, conf) {
					this.infoName = infoName;
					this.similarity = +sim;
					this.confidence = +conf;
				}
				getResult() {
				
					let isValid = false;
					let nameValue = "";
					let colorValue =  "#dd0000";
				
					let realStatus = this.confidence >= getSliderValue(this.infoName + "Sim");
					let predictedStatus = this.similarity >= getSliderValue(this.infoName + "Conf");
					
					if (predictedStatus) {
						if (realStatus) {
							nameValue = "TP";
							colorValue = "#00dd00";
							isValid = true;
						}
						else {
							nameValue = "FP";
						}
					}
					else {
						if (realStatus) {
							nameValue = "FN";
							colorValue = "#dddd00";
						}
						else {
							nameValue = "TN";
							colorValue = "#dddddd";
						}
					}
					return [isValid, nameValue, colorValue];
				}
			}
			
			class ElementInfo {
				constructor(procError, qaInfo, classInfo, extractInfo) {
					this.procError = +procError;
					this.qaInfo = qaInfo;
					this.classInfo = classInfo;
					this.extractInfo = extractInfo;
				}
				
				updateMap() {
					let qtd = this.extractInfo.length;
				
					// preprocessamento
					let processName = this.procError == 1 ? "1_Error" : "1_OK";
					let validProcess = processName === "1_OK";
					
					incrementSankeyData("0_Base", processName, qtd, validProcess ? "#00dd00" : "#dd0000" )
					
					if(validProcess) {
						
						// qualidade
						let res = this.qaInfo.getResult();
						let qaName = "2_" + res[1];
						incrementSankeyData(processName, qaName, qtd, res[2]);
						if(res[0]) {
						
							// classificação
							res = this.classInfo.getResult();
							let className = "3_" + res[1];
							incrementSankeyData(qaName, className, qtd, res[2]);
							if(res[0]) {

								this.extractInfo.forEach(d => {
									// campos
									let extractName = "4_" + d.infoName;
									incrementSankeyData(className, extractName, 1, "#dddddd");
									
									// extração
									res = d.getResult();
									incrementSankeyData(extractName, "5_" + res[1], 1, res[2]);
								});
							}
						}
					}
				}
			}
			
//  Variaveis globais  //
			let dataset = undefined;
			let width = 1000;
			let height = 800;
			var margin = {top: 5, right: 25, bottom: 5, left: 5};
			
			var svg = d3.select("body").append("svg")
				.attr("width", width + margin.left + margin.right)
				.attr("height", height + margin.top + margin.bottom)
				.append("g").attr("transform", "translate(" + margin.left + "," + margin.top + ")");
			
			var nodesGroup = svg.append("g")
				.attr("stroke", "#000");
				
			var linksGroup = svg.append("g")
				.attr("fill", "none")
				.attr("stroke-opacity", 0.5);
				
			var textsGroup = svg.append("g")
					.attr("font-family", "sans-serif")
					.attr("font-size", 14);
					
			var sankey = d3.sankey()
				.nodeId(d => d.name)
				.nodeWidth(15)
				.nodePadding(20)
				.nodeAlign(d3.sankeyLeft)
				.extent([[1, 5], [width - 1, height - 5]]);
			
			var mapNodes = undefined;
			var mapLinks = undefined;
			
//  Dados  //
			// Lendo Arquivo
			d3.csv("https://raw.githubusercontent.com/EduardoCintraSimoes/ProjetoVisualizacao/main/dataset.csv")
			//d3.csv("dataset.csv")
				.then(function(data){
					//processar dados
					dataset = [];

					data.forEach(function(element){
						let qaInfo = new QualityInfo(element);
						let classInfo = new ClassificationInfo(element);
					
						dataset.push(new ElementInfo(element.processorError, qaInfo, classInfo, [
							new ExtractionInfo("expeditionDate", element.expeditionDateSim, element.expeditionDateSim),
							new ExtractionInfo("birthdate", element.birthdateSim, element.birthdateConf),
							new ExtractionInfo("filiationA", element.filiationASim, element.filiationAConf),
							new ExtractionInfo("filiationB", element.filiationBSim, element.filiationBConf),
							new ExtractionInfo("birthplace", element.birthplaceSim, element.birthplaceConf),
							new ExtractionInfo("name", element.nameSim, element.nameConf),
							new ExtractionInfo("cpf", element.cpfSim, element.cpfConf),
							new ExtractionInfo("rg", element.rgSim, element.rgConf)]));
					});
					setInterface();
				});

//  Funções  //
			//Seta os eventos
			function setInterface(){
			
				var newGroup = d3.select("body").append("table").attr("border",1);//.append("g");
			
				// controles de qualidade
				var rowGroup = newGroup.append("tr");
				setSlider(rowGroup.append("th"), "qaDpi", "DPI", 100, 400, 200);
				setSlider(rowGroup.append("th"), "qaDensity", "Densidade", 0, 50, 5, 0.1);
				setSlider(rowGroup.append("th"), "qaInclination", "Inclinação", 0, 40, 2, 0.1);
				setSlider(rowGroup.append("th"), "qaLightness", "Iluminação", 0, 100, 60);
				setSlider(rowGroup.append("th"), "qaShadow", "Sombra", 0, 100, 60);
				setSlider(rowGroup.append("th"), "qaFocus", "Foco", 0, 100, 60);
				setSlider(rowGroup.append("th"), "qaShine", "Brilho", 0, 100, 60);
				
				// controles de classificação
				setSlider(rowGroup.append("th"), "classifConf", "Classificação", 0, 100, 30);
				
				// controles de extração
				var rowGroup = newGroup.append("tr");
				setExtractionSlider(rowGroup.append("th"), "expeditionDate", "Data de Expedição");
				setExtractionSlider(rowGroup.append("th"), "birthdate", "Data de Nascimento");
				setExtractionSlider(rowGroup.append("th"), "filiationA", "Filiação A");
				setExtractionSlider(rowGroup.append("th"), "filiationB", "Filiação B");
				setExtractionSlider(rowGroup.append("th"), "birthplace", "Naturalidade");
				setExtractionSlider(rowGroup.append("th"), "name", "Nome");
				setExtractionSlider(rowGroup.append("th"), "cpf", "CPF");
				setExtractionSlider(rowGroup.append("th"), "rg", "RG");
				
				drawData();
			}

			function setExtractionSlider(newGroup, name, text) {
				newGroup.text(text); // título
				newGroup.append("br");
				setSlider( newGroup, name + "Conf", "Confiança", 0, 100, 70); // confiança
				newGroup.append("br");
				setSlider( newGroup, name + "Sim", "Similaridade", 0, 100, 90); // similaridade
			}

			function setSlider(newGroup, name, text, minVal, maxVal, defaultVal, step = 1) {
				var sliderTag = name + "Slider";
				var labelTag = name + "Label";
				
				// texto
				newGroup.append("label").text(text + ": ");
				newGroup.append("label").attr("id", labelTag).text(defaultVal);
				newGroup.append("br");
				
				// barra
				newGroup.append("input").attr("id", sliderTag).attr("type", "range").attr("step",step)
					.attr("min", minVal).attr("max", maxVal).attr("value", defaultVal).attr("list","tickmarks");
				
				//evento de mudança do valor do slider
				d3.select("#" + sliderTag).on("change",function(){
					let aux = getSliderValue(name);
					d3.select("#" + labelTag).text(aux);
					drawData();
				});
			}
			
			// retorna o valor da barra
			function getSliderValue(name) {
				return +d3.select("#" + name + "Slider").node().value;
			}
						
			function incrementSankeyData(leftName, rightName, qtd, colorVal) {
				if (!mapNodes.has(leftName)) mapNodes.set(leftName, { name: leftName, color: "#aaaaaa" });
				if (!mapNodes.has(rightName)) mapNodes.set(rightName, { name: rightName, color: colorVal });
				
				let tag = leftName + "_" + rightName;
				if(!mapLinks.has(tag)) {
					mapLinks.set(tag, {source: leftName, target: rightName, value: qtd});
				}
				else {
					mapLinks.get(tag).value += qtd;
				}
			}
			
			function darkenColor(color, amount) {
				const [r, g, b] = color.match(/\w\w/g).map((c) => parseInt(c, 16));
				const nR = Math.round(r * amount).toString(16).padStart(2, '0');
				const nG = Math.round(g * amount).toString(16).padStart(2, '0');
				const nB = Math.round(b * amount).toString(16).padStart(2, '0');
				return '#' + nR + nG + nB;
			}
			
			//Desenha gráfico
			function drawData(){
				mapLinks = new Map();
				mapNodes = new Map();
				
				// pega os valores
				dataset.forEach(function(element){
					element.updateMap();
				});
				
				// dados
				var nodes = Array.from(mapNodes.values());
				var links = Array.from(mapLinks.values());
				
				var graph = sankey({
					nodes: nodes.map(d => Object.assign({}, d)),
					links: links.map(d => Object.assign({}, d))
				});
				
				nodesGroup
					.selectAll("rect")
						.data(graph.nodes)
							.join("rect")
								.attr("x", d => d.x0)
								.attr("y", d => d.y0)
								.attr("height", d => d.y1 - d.y0)
								.attr("width", d => d.x1 - d.x0)
								.attr("fill", d => d.color)
								.append("title")
									.text(d => d.name);
				
				const link = linksGroup
					.selectAll("g")
					.data(graph.links)
					.join("g")
						.style("mix-blend-mode", "multiply");
				
				link.selectAll("linearGradient").remove(); // remove linhas antigas		
				const gradient = link.append("linearGradient")
					.attr("id", d => fixStr(d.source.name + d.target.name))
					.attr("gradientUnits", "userSpaceOnUse")
					.attr("x1", d => d.source.x1)
					.attr("x2", d => d.target.x0);

				gradient.append("stop")
					.attr("offset", "0%")
					.attr("stop-color", d => darkenColor(d.target.color, 0.5));//d.source.color);

				gradient.append("stop")
					.attr("offset", "100%")
					.attr("stop-color", d => d.target.color);
					
				link.selectAll("path").remove(); // remove linhas antigas		
				link.append("path")
					.attr("d", d3.sankeyLinkHorizontal())
					.attr("stroke", d => "url(#" + fixStr(d.source.name + d.target.name) + ")" )
					.attr("stroke-width", d => Math.max(1, d.width));

				textsGroup
					.selectAll("text")
					.data(graph.nodes)
						.join("text")
							.attr("x", d => d.x1 + 6)
							.attr("y", d => (d.y1 + d.y0) / 2)
							.attr("dy", "0.35em")
							.attr("text-anchor", "start" )
							.text(d => d.name.substring(d.name.indexOf('_') + 1));
			}
			
			function fixStr(str) {
				return str.replace(/[^0-9a-zA-Z]/g, "_")
			}
			
		</script>

	</body>
</html>